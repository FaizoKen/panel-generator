{
  "version": 3,
  "sources": ["../../simple-markdown/simple-markdown.js"],
  "sourcesContent": ["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = global || self, global.SimpleMarkdown = factory());\n}(this, (function () { 'use strict';\n\n/* @flow */\n/* @ts-check */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n// Typescript language & simple-markdown.d.ts references:\n/// <reference lib=\"ES2018\" />\n/// <reference path=\"../simple-markdown.d.ts\" />\n\n/*::\n// Flow Type Definitions:\n\ntype Capture =\n    Array<string> & {index: number} |\n    Array<string> & {index?: number};\n\ntype Attr = string | number | boolean | null | void;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {\n    key?: string | number | void,\n    inline?: ?boolean,\n    [string]: any,\n};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = { regex?: RegExp } & (\n    source: string,\n    state: State,\n    prevCapture: string\n) => ?Capture;\n\ntype Parser = (\n    source: string,\n    state?: ?State\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => (UnTypedASTNode | ASTNode);\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: ?State\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n};\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +tableSeparator: DefaultInRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n    alt?: string,\n};\n\n// End Flow Definitions\n*/\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n * @param {string} source\n * @returns {string}\n */\nvar preprocess = function(source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\n/**\n * @param {SimpleMarkdown.OptionalState} givenState\n * @param {SimpleMarkdown.OptionalState} defaultState\n * @returns {SimpleMarkdown.State}\n */\nvar populateInitialState = function(\n    givenState /* : ?State */,\n    defaultState /* : ?State */\n) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function(type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                String(order)\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var ruleA /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeA] /*:: :any */);\n        var ruleB /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeB] /*:: :any */);\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.Parser} */\n    var nestedParse = function(source /* : string */, state /* : ?State */) {\n        /** @type Array<SimpleMarkdown.SingleASTNode> */\n        var result = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n            var currRule /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ ( rules[currRuleType] /*:: :any */ );\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality ? currRule.quality(\n                        currCapture,\n                        state,\n                        prevCaptureStr\n                    ) : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = /*::((*/ /** @type {SimpleMarkdown.ParserRule} */ (rules[currRuleType]) /*:: : any) : ParserRule)*/;\n\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule && (\n                    // if we don't have a match yet, continue\n                    !capture || (\n                        // or if we have a match, but the next rule is\n                        // at the same order, and has a quality measurement\n                        // functions, then this rule must have a quality\n                        // measurement function (since they are sorted before\n                        // those without), and we need to check if there is\n                        // a better quality match\n                        currRule.order === currOrder &&\n                        currRule.quality\n                    )\n                )\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null /*:: || ruleType == null */) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                    \"content. The rule with highest `order` should \" +\n                    \"always match content provided to it. Check \" +\n                    \"the definition of `match` for '\" +\n                    ruleList[ruleList.length - 1] +\n                    \"'. It seems to not match the following source:\\n\" +\n                    source\n                );\n            }\n            if (capture.index) { // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                    \"(the current parse index). Did you forget a ^ at the \" +\n                    \"start of the RegExp?\"\n                );\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(/** @type {SimpleMarkdown.SingleASTNode} */ (parsed));\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n        return result;\n    };\n\n    /** @type {SimpleMarkdown.Parser} */\n    var outerParse = function(source /* : string */, state /* : ?State */) {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar inlineRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar blockRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar anyScopeRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\n/**\n * @param {string} type\n * @param {string | number | null | undefined} key\n * @param {Object<string, any>} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar reactElement = function(\n    type /* : string */,\n    key /* : string | number | null | void */,\n    props /* : { [string]: any } */\n) /* : ReactElement */ {\n    var element /* : ReactElement */ = /** @type {SimpleMarkdown.ReactElement} */ ({\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null\n    } /* : any */);\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function(\n    tagName /* : string */,\n    content /* : string */,\n    attributes /* : ?{[any]: ?Attr} */,\n    isClosed /* : ?boolean */\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attribute) {\n            attributeString += \" \" +\n                sanitizeText(attr) + '=\"' +\n                sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function(url /* : ?string */) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\n/** @type {any} */\nvar SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n};\n/**\n * @param {SimpleMarkdown.Attr} text\n * @returns {string}\n */\nvar sanitizeText = function(text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function(chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\n/**\n * @param {string} rawUrlString\n * @returns {string}\n */\nvar unescapeUrl = function(rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n *\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n/**\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.Parser} parse\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\n/**\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function() {\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    /**\n     * @param {string} alignCapture\n     * @returns {SimpleMarkdown.TableAlignment}\n     */\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {Array<SimpleMarkdown.TableAlignment>}\n     */\n    var parseTableAlign = function(source, parse, state, trimEndSeparators) {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleASTNode[][]}\n     */\n    var parseTableRow = function(source, parse, state, trimEndSeparators) {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        /** @type {SimpleMarkdown.SingleASTNode[][]} */\n        var cells = [[]];\n        tableRow.forEach(function(node, i) {\n            if (node.type === 'tableSeparator') {\n                // Filter out empty table separators at the start/end:\n                if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (node.type === 'text' && (\n                    tableRow[i + 1] == null ||\n                    tableRow[i + 1].type === 'tableSeparator'\n                )) {\n                    node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function(source, parse, state, trimEndSeparators) {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function(trimEndSeparators) {\n        /** @type {SimpleMarkdown.SingleNodeParseFunction} */\n        return function(capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n            var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n            var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.State} state\n * @param {SimpleMarkdown.RefNode} refNode\n * @returns {SimpleMarkdown.RefNode}\n */\nvar parseRef = function(capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n/** @type {SimpleMarkdown.DefaultRules} */\nvar defaultRules /* : DefaultRules */ = {\n    Array: {\n        react: function(arr, output, state) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = '' + i;\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function(arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0; i < arr.length; i++) {\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        }\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'h' + node.level,\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        },\n        react: null,\n        html: null\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'hr',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        }\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement(\n                'pre',\n                state.key,\n                {\n                    children: reactElement(\n                        'code',\n                        null,\n                        {\n                            className: className,\n                            children: node.content\n                        }\n                    )\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        }\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        },\n        react: null,\n        html: null\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content, state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'blockquote',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    list: {\n        order: currOrder++,\n        match: function(source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = /** @type {string[]} */ (\n                capture[0]\n                    .replace(LIST_BLOCK_END_R, \"\\n\")\n                    .match(LIST_ITEM_R)\n            );\n\n            // We know this will match here, because of how the regexes are\n            // defined\n            /*:: items = ((items : any) : Array<string>) */\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(/** @type {string} */ item, /** @type {number} */ i) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // I'm not sur4 why this is necessary again?\n                /*:: items = ((items : any) : Array<string>) */\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(\n                ListWrapper,\n                state.key,\n                {\n                    start: node.start,\n                    children: node.items.map(function(\n                        /** @type {SimpleMarkdown.ASTNode} */ item,\n                        /** @type {number} */ i\n                    ) {\n                        return reactElement(\n                            'li',\n                            '' + i,\n                            {\n                                children: output(item, state)\n                            }\n                        );\n                    })\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(/** @type {SimpleMarkdown.ASTNode} */ item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(/** @type {SimpleMarkdown.RefNode} */ refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return \"\"; }\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {{ [attr: string]: SimpleMarkdown.Attr }}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return reactElement(\n                    'th',\n                    '' + i,\n                    {\n                        style: getStyle(i),\n                        scope: 'col',\n                        children: output(content, state)\n                    }\n                );\n            });\n\n            var rows = node.cells.map(function(\n                    /** @type {SimpleMarkdown.ASTNode[]} */ row,\n                    /** @type {number} */ r\n            ) {\n                return reactElement(\n                    'tr',\n                    '' + r,\n                    {\n                        children: row.map(function(\n                            /** @type {SimpleMarkdown.ASTNode} */ content,\n                            /** @type {number} */ c\n                        ) {\n                            return reactElement(\n                                'td',\n                                '' + c,\n                                {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                }\n                            );\n                        })\n                    }\n                );\n            });\n\n            return reactElement(\n                'table',\n                state.key,\n                {\n                    children: [reactElement(\n                        'thead',\n                        'thead',\n                        {\n                            children: reactElement(\n                                'tr',\n                                null,\n                                {\n                                    children: headers\n                                }\n                            )\n                        }\n                    ), reactElement(\n                        'tbody',\n                        'tbody',\n                        {\n                            children: rows\n                        }\n                    )]\n                }\n            );\n        },\n        html: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {string}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i), scope: \"col\" });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(/** @type {SimpleMarkdown.ASTNode[]} */ row) {\n                var cols = row.map(function(\n                    /** @type {SimpleMarkdown.ASTNode} */ content,\n                    /** @type {number} */ c\n                ) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        }\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; }\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'div',\n                state.key,\n                {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function(source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function() {\n            return { type: 'tableSeparator' };\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function() { return ' | '; },\n        html: function() { return ' &vert; '; },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        },\n        react: null,\n        html: null\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        },\n        react: null,\n        html: null\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'a',\n                state.key,\n                {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'img',\n                state.key,\n                {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        },\n        react: null,\n        html: null\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        },\n        react: null,\n        html: null\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match at least one of:\n                \"(?:\" +\n                  //  - `**`: so that bolds inside italics don't close the\n                  //          italics\n                  \"\\\\*\\\\*|\" +\n                  //  - escape sequence: so escaped *s don't close us\n                  \"\\\\\\\\[\\\\s\\\\S]|\" +\n                  //  - whitespace: followed by a non-* (we don't\n                  //          want ' *' to close an italics--it might\n                  //          start a list)\n                  \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                  //  - non-whitespace, non-*, non-backslash characters\n                  \"[^\\\\s\\\\*\\\\\\\\]\" +\n                \")+?\" +\n                // followed by a non-space, non-* then *\n                \")\\\\*(?!\\\\*)\"\n            )\n        ),\n        quality: function(capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'em',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        }\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function(capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'strong',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function(capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'u',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        }\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'del',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'code',\n                state.key,\n                {\n                    children: node.content\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        }\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'br',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        }\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return sanitizeText(node.content);\n        }\n    }\n};\n\n/** (deprecated)\n * @param {any} rules\n * @param {any} property\n * @returns {any}\n */\nvar ruleOutput = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    /** @type {SimpleMarkdown.NodeOutput<any>} */\n    var nestedRuleOutput /* : NodeOutput<any> */ = function(\n        ast /* : SingleASTNode */,\n        outputFunc /* : Output<any> */,\n        state /* : State */\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar reactFor = function(outputFunc /* : ReactNodeOutput */) /* : ReactOutput */ {\n    /** @type {SimpleMarkdown.ReactOutput} */\n    var nestedOutput /* : ReactOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = '' + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar htmlFor = function(outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */ {\n    /** @type {SimpleMarkdown.HtmlOutput} */\n    var nestedOutput /* : HtmlOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/**\n * @type {SimpleMarkdown.OutputFor}\n */\nvar outputFor = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */,\n    defaultState /* : ?State */\n) {\n    if (!property) {\n        throw new Error('simple-markdown: outputFor: `property` must be ' +\n            'defined. ' +\n            'if you just upgraded, you probably need to replace `outputFor` ' +\n            'with `reactFor`'\n        );\n    }\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.ArrayRule} */\n    var arrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error('simple-markdown: outputFor: to join nodes of type `' +\n            property + '` you must provide an `Array:` joiner rule with that type, ' +\n            'Please see the docs for details on specifying an Array rule.'\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var nestedOutput /* : Output<any> */ = function(ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var outerOutput = function(ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultBlockParse = function(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultInlineParse = function(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultImplicitParse = function(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\n/** @type {SimpleMarkdown.ReactOutput} */\nvar defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\n/** @type {SimpleMarkdown.HtmlOutput} */\nvar defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {SimpleMarkdown.ReactElements}\n */\nvar markdownToReact = function(source, state) /* : ReactElements */ {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {string}\n */\nvar markdownToHtml = function(source, state) /* : string */ {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n/**\n * @param {SimpleMarkdown.ReactMarkdownProps} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar ReactMarkdown = function(props) {\n    /** @type {Object} */\n    var divProps = {};\n\n    for (var prop in props) {\n        if (prop !== 'source' &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\n        'div',\n        null,\n        divProps\n    );\n};\n\n\n/*:: // Flow exports:\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n\n    +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (tagName: string, content: string, attributes: ?{ [any]: ?Attr }, isClosed: ?boolean) => string,\n    +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n};\n*/\n\nvar SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n        }\n        return defaultImplicitParse.apply(null, /** @type {any} */ (arguments));\n    },\n    defaultOutput: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n        }\n        return defaultReactOutput.apply(null, /** @type {any} */ (arguments));\n    }\n};\n\nreturn SimpleMarkdown;\n\n})));\n"],
  "mappings": "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",
  "names": ["currOrder"]
}
